## Условия задач

### A. Выражения-генераторы

Вам предлагается набор из задачек, для каждой из которых решение — одно выражение-генератор.

1. Трансформация выражения (переведите выражение слева в выражение справа):
```
'python' -> ['pppp', 'yyyy', 'tttt', 'hhhh', 'oooo', 'nnnn']
```

2. Трансформация выражения:
```
'python' -> ['p', 'yy', 'ttt', 'hhhh', 'ooooo', 'nnnnnn']
```

3. Трансформация выражения:
```
range(16) -> [0, 3, 5, 6, 9, 10, 12, 15]
```

4. Трансформация выражения:
```
[[1, 2, 3], [4, 5, 6, 7], [8, 9], [0]] -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
```
**Замечание:** запрещается использовать функции `chain` и `chain.from_iterable` из модуля `itertools`.

5. Пифагоровы тройки.

Выведите все уникальные [пифагоровы тройки](https://ru.wikipedia.org/wiki/%D0%9F%D0%B8%D1%84%D0%B0%D0%B3%D0%BE%D1%80%D0%BE%D0%B2%D0%B0_%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0), где каждое из чисел не превосходит _n_. На вход подается число _n_ (_n_ ≤ 30).
```
15 -> [(3, 4, 5), (5, 12, 13), (6, 8, 10), (9, 12, 15)]
```
Обратите внимание, что для любой пифагоровой тройки _(a, b, c)_ из примера выполнено условие _a_ ≤ _b_ ≤ _c_.

6. Трансформация выражения:
```
([0, 1, 2], [0, 1, 2, 3, 4]) -> [[0, 1, 2, 3, 4], [1, 2, 3, 4, 5], [2, 3, 4, 5, 6]]
```

7. Транспонирование матрицы.
```
[[1, 2], [3, 4], [5, 6]] -> [[1, 3, 5], [2, 4, 6]]
[[1, 3, 5], [2, 4, 6]] -> [[1, 2], [3, 4], [5, 6]]
```
**Замечание:** запрещается использовать сторонние библиотеки, например, `scipy` и `numpy`.

8. Трансформация выражения:
```
["0", "1 2 3", "4 5 6 7", "8 9"] -> [[0], [1, 2, 3], [4, 5, 6, 7], [8, 9]]
```
Используйте функцию `map` для конвертации строк в числа. В этом задании вам должен помочь метод `split()` для строк.

9. Трансформация выражения:
```
range(0, 7) -> {'a': 0, 'b': 1, 'c': 4, 'd': 9, 'e': 16, 'f': 25, 'g': 36}
```
**Замечание:** запрещается использовать ключевое слово `dict`, используйте фигурные скобки.

10. Трансформация выражения:
```
['Alice', 'vova', 'ANTON', 'Bob', 'kAMILA', 'CJ', 'ALICE', 'Nastya'] -> {'Alice', 'Anton', 'Kamila', 'Nastya', 'Vova'}
```
**Замечание:** запрещается использовать ключевое слово set, используйте фигурные скобки.

Оставьте все уникальные имена длины больше 3. Вам может пригодиться `set`.

**Формат результата**

Оформите свое решение в виде функций `solution{n}(arg)`, где `{n}` — номер задания. На вход этим функциям в качестве аргумента будут подаваться выражения из левой части. Поместите ваши функции в словарь.
```python
solutions = {
    'solution1': solution1,
    'solution2': solution2,
    'solution3': solution3,
    'solution4': solution4,
    'solution5': solution5,
    'solution6': solution6,
    'solution7': solution7,
    'solution8': solution8,
    'solution9': solution9,
    'solution10': solution10,
}
```

**Примечания**

Напомним, что выражение `[i ** 2 for i in range(10)]` является примером выражения-генератора.

Каждой задаче соответствует один тест. Задачи и тесты пронумерованы в одном порядке.
Например, если у вас не проходит 4-й тест, значит вы решили 4-ю задачу неправильно.

Если вы не знаете, как решить задачу с номером k, то оформите ее решение следующим образом:
```python
def solution{k}(arg):
    pass
```

В данном задании не предполагается использование каких-либо собственных функций, помимо функций `solution{n}`. Если же у вас СОВСЕМ не получается решить задачу без них, то написание и использование дополнительных функций не запрещено.

### B. map, filter и reduce

Вам предлагается набор из задачек, для каждой из которых решение — одно выражение с использованием функций `map`, `filter` и `reduce`.

1. Трансформация выражения (переведите выражение слева в выражение справа):
```
['12', '25.6', '84,02', '  69-91'] -> [21, 652, 2048, 1996]
```
Используйте библиотеку `re`.

2. Трансформация выражения:
```
zip(range(2, 5), range(3, 9, 2)) -> [6, 15, 28]
```

3. Трансформация выражения:
```
range(20) -> [0, 2, 5, 6, 8, 11, 12, 14, 17, 18]
```
Обратите внимание на остаток при делении на 6.

4. Трансформация выражения:
```
['', 25, None, 'python', 0.0, [], ('msu', '1755-01-25')] -> [25, 'python', ('msu', '1755-01-25')]
```
Что общего между всеми удаленными элементами списка? Что будет, если тип каждого элемента списка привести к `bool`? Прочитайте документацию к функции `filter`.

5. Добавьте к каждому элементу списка `rooms` поле `square`, показывающее площадь комнаты. Элементы списка `rooms` ДОЛЖНЫ обновиться!
```
rooms = [
    {"name": "комната1", "width": 2, "length": 4},
    {"name": "комната2", "width": 2.5, "length": 5.6},
    {"name": "кухня", "width": 3.5, "length": 4},
    {"name": "туалет", "width": 1.5, "length": 1.5},
]
```
Используйте функцию `setitem` для добавления/модификации элементов в словаре из модуля `operator`.

6. Добавьте к каждому элементу списка `rooms` поле `square`, показывающее площадь комнаты. Элементы исходного списка `rooms` НЕ ДОЛЖНЫ обновиться! Порядок элементов в результирующем списке должен совпадать с порядком в исходном списке.

Обратите внимание на конструктор словаря (`dict`). Вспомните про механизм распаковки.

**Замечание:** запрещается использовать модуль copy.

7. Найдите пересечение всех множеств. Используйте функцию `reduce`.
```
[{1, 2, 3, 4, 5}, {2, 3, 4, 5, 6}, {3, 4, 5, 6, 7}] -> {3, 4, 5}
```

8. Посчитайте, сколько раз встречается каждый элемент в списке.
```
[1, 2, 1, 1, 3, 2, 3, 2, 4, 2, 4] -> {1: 3, 2: 4, 3: 2, 4: 2}
```
Обратите внимание на аргумент `initial` функции `reduce`. Для модификации значения в словаре используйте функцию `setitem` из модуля `operator`.

Чему равен результат выражения `None and 5`? А выражения `None or 5`?
Что будет, если заменить `None` на функцию (например, печатающую фразу **Hello world!**), возвращающую `None`?

Ответы на эти вопросы рекомендуется проверить в интерпретаторе языка.

**Замечание:** запрещается использовать класс `Counter` из модуля `collections`.

9. Выведите имена студентов, чей _gpa > 4.5_.
```
students = [
    {'name': 'Alina', 'gpa': 4.57},
    {'name': 'Sergey', 'gpa': 5.0},
    {'name': 'Nastya', 'gpa': 4.21},
    {'name': 'Valya', 'gpa': 4.72},
    {'name': 'Anton', 'gpa': 4.32},
]

students -> ['Alina', 'Sergey', 'Valya']
```

10. Счастливые билетики по-питерски.

Билетик называется счастливым, если сумма цифр на четных местах равна сумме цифр на нечетных. Из исходного списка выведите только счастливые билетики.

**Пример**
```
['165033', '477329', '631811', '478117', '475145', '238018', '917764', '394286'] -> ['165033', '475145', '238018']
```
Как получить все элементы, стоящие на четных/нечетных позициях? Вспомните, как работают срезы.

**Замечание:** разрешается использовать функцию `sum`.

**Формат результата**

Оформите свое решение в виде функций `solution{n}(arg)`, где `{n}` — номер задания. На вход этим функциям в качестве аргумента будут подаваться выражения из левой части (в заданиях на трансформацию) или один из списков: `rooms`, `people`, `students`. Поместите ваши функции в словарь.
```
solutions = {
    'solution1': solution1,
    'solution2': solution2,
    'solution3': solution3,
    'solution4': solution4,
    'solution5': solution5,
    'solution6': solution6,
    'solution7': solution7,
    'solution8': solution8,
    'solution9': solution9,
    'solution10': solution10,
}
```

**Примечания**

Каждой задаче соответствует один тест. Задачи и тесты пронумерованы в одном порядке.
Например, если у вас не проходит 4-й тест, значит вы решили 4-ю задачу неправильно.

Если вы не знаете, как решить задачу с номером k, то оформите ее решение следующим образом:
```python
def solution{k}(arg):
    pass
```

В данном задании не предполагается использование каких-либо собственных функций, помимо функций `solution{n}`. Если же у вас СОВСЕМ не получается решить задачу без них, то написание и использование дополнительных функций не запрещено.

### C. Кто не успел, тот опоздал

В системах реального времени не редко бывают ограничения на время ответа -- пользователь вашего сервиса не будет ждать ответа бесконечно долго. Например, если пользователь что-то ищет в вашем поиске имеет смысл показать ему хоть что-то более менее соответствующее запросу, нежели не показать ничего. Чтобы определить, что мы не успеваем отдать ответ пользователю за заранее определенное время используется механизм таймаутов.

В этом задании предлагается написать декоратор `@timeout(seconds=0.1)`, который будет прерывать выполнение функции и бросать исключение `TimeoutException`, если функция не укладывается в заданное число секунд.
```python
class TimeoutException(RuntimeError):
    def __init__(self, message=None):
        super().__init__(message)
```
Решение предлагается сделать с использование [сигналов](https://docs.python.org/3.7/library/signal.html). В качестве используемого сигнала стоит выбрать `signal.SIGALRM`. Для установки таймера используйте:
```python
signal.setitimer(signal.ITIMER_REAL, seconds)
```
В случае, если аргумент `seconds` равен `None` или является не положительным числом, считается, что таймаут для функции не устанавливается (функция не оборачивается в декоратор).

**Примеры**

Входные данные
```python
from time import sleep

@timeout(seconds=0.5)
def func():
    sleep(0.1)

try:
    func()
except TimeoutException as e:
    print(e)
```
Результат работы
```
```

Входные данные
```python
from time import sleep

@timeout(seconds=0.5)
def func():
    sleep(0.6)

try:
    func()
except TimeoutException as e:
    print(e)
```
Результат работы
```
Timed out
```

**Примечания**

Подробнее почитать о том, что такое сигналы и как с ними взаимодействовать на примере языка Си, можно, например, [тут](https://www.ibm.com/developerworks/ru/library/l-signals_1/index.html). В Windows нет полноценной поддержки сигналов, поэтому пользователям этой ОС рекомендуется использовать [онлайн IDE](https://repl.it/languages/python3).

Класс `TimeoutException` разместите внутри файла с вашим решением.

Если для функции, согласно условию, не выставляется таймаут, то декоратор должен вернуть саму функцию.

После того, как функция завершилась, не забудьте вернуть на место старый `handler` для сигнала или `signal.SIG_DFL`.

С помощью `signal.setitimer` устанавливается таймер, по истечении таймера программе посылается `signal.SIGALRM`.

Не забудьте перекрыть имя декорируемой функции через декоратор из модуля `functools`.

Функция, обернутая в декоратор, должна возвращать то же значение, что и функция без декоратора. В задаче НЕ гарантируется, что оборачиваемая функция не принимает на вход аргументов.

### D. Счетчики

Напишите декоратор `@counter`, который позволял бы посчитать глубину рекурсии функции и количество рекурсивных вызовов функции.

Декоратор должен создать два атрибута для функции:
* `ncalls` — число вызовов функции;
* `rdepth` — глубина рекурсии.

Счетчики `ncalls` и `rdepth` должны обнуляться при каждом новом входе в рекурсию, см. примеры.

**Примеры**

Входные данные
```python
@counter
def func1():
    return

if __name__ == "__main__":
    func1()
    print(func1.ncalls, func1.rdepth)

    func1()
    print(func1.ncalls, func1.rdepth)
```
Результат работы
```
1 1
1 1
```

Входные данные
```python
@counter
def func2(n, steps):
    if steps == 0:
        return

    func2(n + 1, steps - 1)
    func2(n - 1, steps - 1)

if __name__ == "__main__":
    func2(0, 5)
    print(func2.ncalls, func2.rdepth)

    func2(0, 3)
    print(func2.ncalls, func2.rdepth)
```
Результат работы
```
63 6
15 4
```

**Примечания**

Не забудьте перекрыть имя декорируемой функции через декоратор из модуля `functools`.

Функция, обернутая в декоратор, должна возвращать то же значение, что и функция без декоратора. В задаче НЕ гарантируется, что оборачиваемая функция не принимает на вход аргументов.

### E. Змейка

В модуле `itertools` есть функция `chain`, которая позволяет последовательно объединять несколько итерируемых объектов.

Напишите генератор-функцию `chain_loop(args)`, который бы:
* циклически обходил бы объекты в `args`;
* из каждого объекта элементы извлекались бы в порядке их очереди;
* если в некотором объекте элементы закончились, то этот объект нужно игнорировать (см. замечание) при циклическом обходе;
* генератор завершает свою работу тогда, когда все элементы из всех объектов в `args` были извлечены.

**Обратите внимание** на требования к реализации, см. ниже.

Постарайтесь придумать **максимально** общее решение без предположения о том, что какие-то значения точно будут отсутствовать в элементах `args`.

**Примеры**

Входные данные
```python
a = range(5)
b = range(10)
c = range(3)

print(list(chain_loop([a, b, c])))
```
Результат работы
```
[0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 6, 7, 8, 9]
```

Входные данные
```python
a = [None, None, None]
b = [1] * 5

print(list(chain_loop([a, b])))
```
Результат работы
```
[None, 1, None, 1, None, 1, 1, 1]
```

Входные данные
```python
a = (i for i in range(10))
b = a

print(list(chain_loop([a, b])))
```
Результат работы
```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Входные данные
```python
from itertools import tee

a = (i for i in range(3))

print(list(chain_loop(tee(a, 5))))
```
Результат работы
```
[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2]
```

**Примечания**

Пусть элементы в объекте o из `args` закончились. Требуется придумать такой алгоритм, при котором не будут совершаться попытки получения элементов из o при повторных циклических обходах `args`. Помните, что ловить исключения **дорого**.

Допускается ловить **не более**, чем одно исключение на каждый элемент из `args`.

**Запрещается** хранить все значения внутри генератора.

### F. Скобочные последовательности

Рассмотрим последовательность из _n_ открывающихся и _n_ закрывающихся круглых скобок. Последовательность называется правильной, если в любом ее префиксе число открывающих скобок не меньше числа закрывающих. Префиксом последовательности называется последовательность из первых _k_ (целое) элементов последовательности.

Все правильные последовательности для _n = 3_:
```
()()(), (())(), ()(()), (()()), ((()))
```

Напишите функцию-генератор `brackets(n)` всех правильных скобочных последовательностей длины _2n_.

**Формат входных данных**

На вход вашей программе подается единственное число _n_ (0 ≤ _n_ ≤ 10).

**Формат результата**

Выведите все правильные скобочные последовательности длины _2n_ в лексикографическом порядке.

**Примеры**

Входные данные
```
3
```
Результат работы
```
((()))
(()())
(())()
()(())
()()()
```

Входные данные
```
0
```
Результат работы
```
```

Входные данные
```python
for i in brackets(3):
    print(i)
```
Результат работы
```
((()))
(()())
(())()
()(())
()()()
```

**Примечания**

**Запрещается** хранить все значения внутри генератора.

**Подробнее о лексикографическом порядке.**

Сопоставим скобке **(** число _0_, а **)** — _1_. Тогда последовательности можно сопоставить бинарное число, например, **(())()** — _001101_2_ и **((()))** — _000111_2_. Последовательность **(())()** лексикографически больше **((()))**, т. к. _001101_2 > 000111_2_.

**Подсказки:**

1. Рекомендуется решать задачу рекурсивно, но не возбраняется и итеративный подход. Обратите внимание на то, как определяется правильная последовательность в условии, — это ключ к решению.

2. Попробуйте сначала решить задачу без использования генераторов. Если ваша программа работает правильно, то она пройдет все тесты за исключением последнего.

3. С помощью какой конструкции можно внутри генератора отдавать значения из другого генератора?

4. Число правильных последовательностей длины _2n_ равно [_n_-му числу Каталана](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%9A%D0%B0%D1%82%D0%B0%D0%BB%D0%B0%D0%BD%D0%B0).

5. Вам не обязательно реализовывать только одну функцию. Например, вы можете написать две функции: одна отвечает за логику и принимает столько аргументов, сколько вам нужно, а вторая является оберткой для первой.

### G. Неправильный словарь

В модуле `collections` есть класс [`defaultdict`](https://docs.python.org/3.7/library/collections.html#collections.defaultdict), который позволяет создавать словарь со значением по-умолчанию.

Пусть:
* `smartdict` – (обычный) словарь (`dict`), который хранит в себе некоторый `defaultdict`;
* `key` – некоторый ключ в словаре `smartdict`;
* `val` – значение в словаре `smartdict` по ключу `key`: `val = smartdict[key]`.

Значение по-умолчанию для `val` определим, как `smartdict_nan(key)`.

Имеется следующая реализация:
```python
from collections import defaultdict

def smartdict_nan(key):
    return 10 * key

N = 10

smartdict = {}
for key in range(N):
    val = defaultdict(lambda: smartdict_nan(key))
    smartdict[key] = val
```
При такой реализации словарь `smartdict` работает не так, как было задумано.
```console
>>> smartdict[5]['key_unknown']
90 # right answer is 50

>>> smartdict[7]['key_unknown']
90 # right answer is 70

>>> smartdict[2]['key_unknown']
90 # right answer is 20
```
**Объясните**, почему код работает неверно (в комментарии к решению), и **исправьте** ошибку. Разворачивать цикл в последовательные вызовы **запрещено**. Чем подробнее будет ваше объяснение, тем выше вероятность, что оно будет правильно понято и задание будет засчитано.

### H. Магическое префиксное дерево поиска

В этом задании требуется реализовать [префиксное дерево поиска](https://habr.com/ru/post/111874). Как нетрудно догадаться из названия структуры данных, такого рода деревья позволяют достаточно эффективно искать строки имеющие общий префикс.

Ваше решение должно содержать реализацию 3-х классов:
* `Node` – класс, реализующий вершину в дереве;
* `Trie` – класс, реализующий префиксное дерево;
* `TrieIterator` – класс, реализующий итерацию по префиксному дереву **в ширину**.

Ваш класс `Trie` должен поддерживать следующий интерфейс:

1. Класс должен иметь метод `add(word)`, с помощью которого можно сохранить слово `word` в дереве.
2. Класс должен иметь метод `pop(word)`, с помощью которого можно удалить из дерева слово `word`. Если слово отсутсвует, то должно быть брошено исключение `KeyError(word)`.
3. Должна быть возможность получить количество слов в дереве `trie: len(trie)`. Количество элементов в дереве должно вычисляться за _O(1)_.
4. Класс должен поддерживать проверку наличия слова `word` в дереве `trie` через конструкцию `word in trie`. Проверка наличия слова должна быть реализована эффективно, т.е. через поиск **в глубину**.
5. Класс должен поддерживать механизм итерации (с использованием класса `TrieIterator`). Итерирование соответствует обходу дерева **в ширину**. При итерации по дереву требуется получать все слова, находящиеся в дереве.
6. Класс должен иметь метод `starts_with(prefix)`, который возвращает итератор на слова, имеющие префикс `prefix`.

**Примеры**

Входные данные
```python
trie = Trie()

trie.add('apple')
trie.add('mango')
trie.add('juice')

print(len(trie))
print('apple' in trie)
```
Результат работы
```
3
True
```

Входные данные
```python
trie = Trie()

trie.add('apple')
trie.add('mango')
trie.add('juice')

print('apple' in trie)

trie.pop('apple')
print('apple' in trie)
print(len(trie))
```
Результат работы
```
True
False
2
```

Входные данные
```python
trie = Trie()

trie.add('salad')
trie.add('apple')
trie.add('mango')
trie.add('juice')
trie.add('carrot')
trie.add('broccoli')

print(*trie, sep='\n')
```
Результат работы
```
apple
juice
mango
salad
carrot
broccoli
```

Входные данные
```python
trie = Trie()

trie.add('word')
trie.add('world')
trie.add('work')
trie.add('wood')

prefix = trie.starts_with('wor')
print(*prefix, sep='\n')

print()
print(isinstance(prefix, TrieIterator))
```
Результат работы
```
word
work
world

True
```

Входные данные
```python
trie = Trie()

try:
    trie.pop('summary')
except KeyError as e:
    print('Word {} is not found'.format(e))

print(isinstance(iter(Trie), TrieIterator))
```
Результат работы
```
Word 'summary' is not found
True
```

**Примечания**

В реализации обхода в ширину вам может пригодиться класс `deque` из модуля `collections`.

Гарантируется, что слова состоят только из латинских букв и цифр. Буквы и цифры упорядочены согласно ASCII таблице.

В данном задании запрещена сортировка: метод `list.sort` и функция `sorted`.

### I. Хрупкий словарь

В банках всего мира используются SQL-базы данных. Основным преимуществом этих баз данных является высокая скорость доступа к данным, а также выполнение принципов ACID (атомарность, согласованность, изолированность, долговечность). Транзакции обязаны удовлетворять этим принципам, иначе любая ошибка может привести к огромным потерям со стороны банка.

В этом задании предлагается реализовать прототип простейшего "безопасного" хранилища. Наше хранилище будет называться "хрупким словарем". Класс `FragileDict` должен реализовывать следующий интерфейс:
1. Инициализатор опционально может принимать на вход словарь, содержимое которого будет храниться в "хрупком словаре". В конструкторе заполняются два атрибута: `_data` — хранилище с данными, `_lock` — булев флаг, показывающий разрешено ли редактировать хранилище (`True` в положении вне контекста). Других полей быть НЕ должно.
2. Из любого экземпляра класса `FragileDict` можно читать данные аналогично тому, как это делается для словарей, например, `d['key']`. Если ключ (key) отсутствует, то бросается исключение `KeyError(key)`, как если бы это был просто словарь.
3. Класс `FragileDict` должен поддерживать механизм менеджера контекста. Экземпляр класса может создаваться при входе в контекст.
4. В экземпляры класса можно записывать данные аналогично тому, как это делается для словарей, например, `d['key'] = value`. Однако разрешается это делать только внутри контекста. Если этот контракт нарушается, то бросается исключение `RuntimeError("Protected state")`. При входе в контекст разрешается создавать любые атрибуты класса, но на выходе из контекста никаких сторонних атрибутов быть не должно.
5. Если внутри контекста возникло исключение, то данные не записываются. На выходе из контекста "словарь" должен иметь точно такое же состояние, как и на входе. Само исключение подавляется, и пишется сообщение об ошибке **Exception has been suppressed.**.
6. Класс должен поддерживать проверку наличия ключа в формате `key in d`, где _key_ — некоторый ключ, а _d_ — экземпляр класса "хрупкого словаря".

**Примеры**

Входные данные
```python
d = FragileDict({'key': 5})

with d:
    d['key'] = 6
    d['ord'] = 7

print(d['key'])
print(d['ord'])
```
Результат работы
```
6
7
```

Входные данные
```python
d = FragileDict({'key': 5})

try:
    d['key'] = 6
except RuntimeError as e:
    print(e)

try:
    d['ord'] = 7
except RuntimeError as e:
    print(e)

print(d['key'] == 5)
print('ord' not in d)
```
Результат работы
```
Protected state
Protected state
True
True
```

Входные данные
```python
d = FragileDict({'key': 5})

with d:
    d['key'] = 6
    print(d['key'])
    d['ord'] = 7
    print('ord' in d and d['ord'] == 7)
    raise Exception()

print(d['key'])
print('ord' not in d)
```
Результат работы
```
6
True
Exception has been suppressed.
5
True
```

Входные данные
```python
d = FragileDict({'key': []})

with d:
    a = d['key']
    d['key'].append(10)
    a.append(10)

a.append(10)
print(a == [10, 10, 10] and d['key'] == [10, 10])
```
Результат работы
```
True
```

**Примечания**

Как вы вероятно помните, в Python все объекты передаются по ссылке. Для обеспечения большей безопасности вашего хранилища вам должен пригодиться модуль `copy`. Вспомните про разницу между поверхностными копированием (shallow copy) и глубоким копированием (deep copy).
